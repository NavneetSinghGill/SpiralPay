//
//  PinViewController.swift
//  SpiralPay
//
//  Created by Zoeb on 02/02/18.
//  Copyright (c) 2018 EnvisionWorld. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import LocalAuthentication

enum PinEntry {
    case Create
    case ReEnter
    case Login
}

protocol PinDisplayLogic: class
{
    func customerRegistrationSuccess(response: Pin.CustomerRegistration.Response)
    func customerRegistrationFailed(response: Pin.CustomerRegistration.Response)
    
    func loginSuccess(response: Pin.Login.Response)
    func loginFailed(response: Pin.Login.Response)
}

class PinViewController: ProgressBarViewController, PinDisplayLogic
{
  var interactor: PinBusinessLogic?
  var router: (NSObjectProtocol & PinRoutingLogic & PinDataPassing)?

  // MARK: Object lifecycle
  
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
  {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }
  
  required init?(coder aDecoder: NSCoder)
  {
    super.init(coder: aDecoder)
    setup()
  }
  
  // MARK: Setup
  
  private func setup()
  {
    let viewController = self
    let interactor = PinInteractor()
    let presenter = PinPresenter()
    let router = PinRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
  }
  
  // MARK: Routing
  
  override func prepare(for segue: UIStoryboardSegue, sender: Any?)
  {
    if let scene = segue.identifier {
      let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
      if let router = router, router.responds(to: selector) {
        router.perform(selector, with: segue)
      }
    }
  }
  
  // MARK: View lifecycle
  
    override func viewDidLoad()
    {
        super.viewDidLoad()
        
        initialSetup()
        
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        self.navigationController?.setNavigationBarHidden(true, animated: false)
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        if pinEntry == .Login && UserDefaults.standard.bool(forKey: Constants.kIsFingerPrintEnabled) {
            didAuthenticateTouchOnce = false
            authenticateUser()
        } else {
            codeTextField.becomeFirstResponder()
        }
    }
  
  // MARK: Do something
    
    @IBOutlet weak var codeTextField: UITextField!
    @IBOutlet weak var headingLabel: UILabel!
    @IBOutlet weak var subHeadingLabel: UILabel!
    @IBOutlet weak var passwordDoesntMatch: UILabel!
    @IBOutlet var pins: [UIButton]!
    @IBOutlet weak var fingerPrintButton: UIButton!
    
    var pinEntry: PinEntry = .Create
    var createdPin: String?
    
    var screenType = AppFlowType.Onboard
    
    let pinDoesntMatchText = "PIN code doesn't match"
    let enterPinOrTouchIDtext = "Please enter your PIN or Touch ID to log in"
    
    var touchRetries: Int = 1
    var touchMaxRetries: Int = 5
    
    var pinRetries: Int = 1
    var pinMaxRetries: Int = 3
    
    var didAuthenticateTouchOnce: Bool = false //It is used to disable error popup at the start of app
    
    //MARK: - API
    //MARK: Customer registration
    func doCustomerRegistrationWith(pin: String?)
    {
        NLoader.startAnimating()
        
        //This removes space from country code
        
        var request = Pin.CustomerRegistration.Request()
        request.email = User.shared.email
        request.pinCode = pin
        request.phone = User.shared.phoneWithCode
        interactor?.doCustomerRegistration(request: request)
    }
    
    func customerRegistrationSuccess(response: Pin.CustomerRegistration.Response) {
        NLoader.stopAnimating()
        
        User.shared.accessToken = response.accessToken
        User.shared.customerID = response.customerId
        if screenType == .Onboard {
            User.shared.savedState = SavedState.PinCreated
        }
        User.shared.save()
        
        Utils.shared.startAccessTokenExpiryTimer()
        
        router?.routeToPhoneVerificationProcess()
        
        User.shared.save(pin: createdPin ?? "")
    }
    
    func customerRegistrationFailed(response: Pin.CustomerRegistration.Response) {
        NLoader.stopAnimating()
    }
    
    //MARK: Login
    
    func loginSuccess(response: Pin.Login.Response) {
        
        Utils.shared.startAccessTokenExpiryTimer()
        
        NLoader.shared.stopNLoader()
        
        User.shared.accessToken = response.accessToken
//        User.shared.accessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjpudWxsLCJ1c2VyX25hbWUiOiJkaWRfMDc5MTlDRTktMUU1RC00MTZELTgzRTYtREY0MTQzNzcyNkZGIiwic2NvcGUiOlsicXJfcGF5bWVudF9jcmVhdGUiLCJxcl9wYXltZW50X3ZpZXciLCJtZXJjaGFudF92aWV3IiwicXJfcGF5bWVudF9wcm9jZXNzIiwiY3VzdG9tZXJfbWFuYWdlIiwicGF5bWVudF92aWV3Il0sIm1lcmNoYW50X2lkIjpudWxsLCJleHAiOjE1MjAyNTY4NDEsImN1c3RvbWVyX2lkIjoiNGRkODI5MDItNzNhNi00MzZiLTk4ZjQtMTk0MTMyOTdhODk1IiwiYXV0aG9yaXRpZXMiOlsibWVyY2hhbnRfdmlldyIsInFyX3BheW1lbnRfY3JlYXRlIiwicXJfcGF5bWVudF92aWV3IiwicGF5bWVudF92aWV3IiwicXJfcGF5bWVudF9wcm9jZXNzIiwiY3VzdG9tZXJfbWFuYWdlIl0sImp0aSI6IjRjOGI1MmQwLWVkMDgtNGFmMC04ODc0LWEyMzcyMWQ4ZTFlOCIsImNsaWVudF9pZCI6InByb21ldGhldXMiLCJ1c2VybmFtZSI6ImRpZF8wNzkxOUNFOS0xRTVELTQxNkQtODNFNi1ERjQxNDM3NzI2RkYifQ.b-I08eqY_EFYCU7clItw7whLcEAonq-_PHgBRlWsfAQ"
        User.shared.save()
        
        DispatchQueue.global().async {
            Utils.shared.startGetVerificationResultTimer(shouldCallApiAtStartOnce: true)
        }
        
        
        
        
        let successBlock = {
            DispatchQueue.main.async {
                if self.navigationController == ApplicationDelegate.getWindow().rootViewController &&
                    self.navigationController?.viewControllers.first == self { //If its the very first screen of app
                    ApplicationDelegate.openIntendedScreen()
                } else {
                    self.navigationController?.dismiss(animated: true, completion: {
                        ApplicationDelegate.executeUniversalLinkingBlock()
                    })
                }
            }
        }
        
        if UserDefaults.standard.bool(forKey: Constants.kIsFingerPrintEnabled) {
            successBlock()
        } else {
            if UserDefaults.standard.bool(forKey: Constants.kDontAskAgainForTouchIDenabling) {
                successBlock()
            } else {
                let enableTouchScreen = EnableTouchViewController.create()
                enableTouchScreen.successBlock = {successBlock()}
                if self.navigationController != nil {
                    self.navigationController?.pushViewController(enableTouchScreen, animated: true)
                } else {
                    self.present(enableTouchScreen, animated: true, completion: nil)
                }
            }
        }
    }
    
    func loginFailed(response: Pin.Login.Response) {
        if response.errorDescription != Constants.kNoNetworkMessage {
            if pinRetries >= pinMaxRetries {
                setupTemporaryLock()
            }
            pinRetries += 1
            updateRetryPINLayout()
        }
        NLoader.shared.stopNLoader()
        
        if response.errorDescription != nil {
            passwordDoesntMatch.text = response.errorDescription
        }
        
        self.passwordDoesntMatch.isHidden = false

        selectDotWith(count: 0)
        codeTextField.text = ""
        codeTextField.becomeFirstResponder()
    }
    
    //MARK:- IBAction methods
    
    @IBAction func fingerprintTapped() {
        authenticateUser()
    }
    
    //MARK:- Private methods
    
    private func initialSetup() {
        if pinEntry == .Create {
            percentageOfProgressBar = CGFloat(2/numberOfProgressBarPages)
        } else if pinEntry == .ReEnter {
            percentageOfProgressBar = CGFloat(3/numberOfProgressBarPages)
        } else {
            progressBar.isHidden = true
        }
        
        fingerPrintButton.isHidden = true
        
        if pinEntry == .ReEnter {
            headingLabel.text = "Re-enter PIN Code"
        } else if pinEntry == .Login {
            headingLabel.text = "Hello!"
            subHeadingLabel.text = enterPinOrTouchIDtext
            passwordDoesntMatch.text = pinDoesntMatchText
            Utils.shared.stopAccessTokenExpiryTimer()
            
            fingerPrintButton.isHidden = !UserDefaults.standard.bool(forKey: Constants.kIsFingerPrintEnabled)
        }
    }
    
    private func selectDotWith(count: Int) {
        var pinCount = 1
        for pin in pins {
            pin.isSelected = pinCount <= count
            pinCount = pinCount + 1
        }
    }
    
    private func pinCreationAndMatchingDoneLocally() {
        doCustomerRegistrationWith(pin: codeTextField.text)
    }
    
    private func doLoginCheckWith(pin: String?) {
        passwordDoesntMatch.isHidden = true
        
        //Reset old access token
        User.shared.accessToken = nil
        
        NLoader.shared.startNLoader()
        
        var request = Pin.Login.Request()
        request.pinCode = pin

        self.interactor?.doLogin(request: request)
    }
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        if !codeTextField.isFirstResponder {
            codeTextField.becomeFirstResponder()
        } else {
            self.view.endEditing(true)
        }
    }
    
    //MARK:- Fingerprint flow methods
    
    func authenticateUser() {
        setFingerprintButton(selection: false)
        
        let context = LAContext()
        context.localizedCancelTitle = "Dismiss"
        context.localizedFallbackTitle = "Retry"
//        if touchRetries == 1 {
//            context.localizedFallbackTitle = "Retry (Attempt 1)"
//        } else if touchRetries == 2 {
//            context.localizedFallbackTitle = "Retry (Attempt 2)"
//        } else if touchRetries == 3 {
//            context.localizedFallbackTitle = "Retry (Attempt 3)"
//        } else if touchRetries == 4 {
//            context.localizedFallbackTitle = "Retry (Last attempt)"
//        } else {
//            context.localizedFallbackTitle = ""
//        }
        
        var error: NSError?
        
        if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) {
            let reason = "Unlock using Touch ID"
            
            context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) {
                [unowned self] success, authenticationError in
                
                DispatchQueue.main.async {
                    if success {
                        self.runSecretCode()
                    } else {
                        var message: String = ""
                        
                        let retryBlock = {
//                            self.touchRetries += 1
//                            if self.touchRetries <= self.touchMaxRetries {
                                self.authenticateUser()
//                            }
                        }
                        
                        if #available(iOS 11.0, *) {
                            switch authenticationError {
                            case LAError.authenticationFailed?:
                                message = "There was a problem verifying your identity."
//                            case LAError.userCancel?:
//                                message = "You pressed cancel."
                            case LAError.userFallback?:
//                                message = "You pressed password."
                                //This fallback is used as Retry button action
                                retryBlock()
                            case LAError.biometryNotAvailable?:
                                message = "Touch ID is not available."
                            case LAError.biometryNotEnrolled?:
                                message = "Touch ID is not set up."
                            case LAError.biometryLockout?:
                                message = "Biometry is locked out."
                            default:
                                message = ""//Touch ID may not be configured"
                            }
                        } else {
                            switch authenticationError {
                            case LAError.authenticationFailed?:
                                message = "There was a problem verifying your identity."
//                            case LAError.userCancel?:
//                                message = "You pressed cancel."
                            case LAError.userFallback?:
//                                message = "You pressed password."
                                //This fallback is used as Retry button action
                                retryBlock()
                            case LAError.touchIDNotAvailable?:
                                message = "Touch ID is not available."
                            case LAError.touchIDNotEnrolled?:
                                message = "Touch ID is not set up."
                            case LAError.touchIDLockout?:
                                message = "Touch ID is locked out."
                            default:
                                message = ""//Touch ID may not be configured"
                            }
                        }
                        if message.count > 0 {
                            print(message)
                            BannerManager.showFailureBanner(subtitle: message)
                            self.setFingerprintButton(selection: true)
                        }
                    }
                }
            }
        } else {
            if UserDefaults.standard.bool(forKey: Constants.kIsFingerPrintEnabled) && didAuthenticateTouchOnce {
                if let error = error {
                    BannerManager.showFailureBanner(subtitle: error.localizedDescription)
                } else {
                    BannerManager.showFailureBanner(subtitle: "Your device is not configured for Touch ID.")
                }
            } else {
                didAuthenticateTouchOnce = true
            }
            setFingerprintButton(selection: true)
        }
    }
    
    func runSecretCode() {
        doLoginCheckWith(pin: User.shared.getPin())
    }
    
    func setFingerprintButton(selection: Bool) {
        if selection {
            fingerPrintButton.isSelected = true
            fingerPrintButton.setImage(UIImage(named: "grayTouchCross"), for: .highlighted)
        } else {
            fingerPrintButton.isSelected = false
            fingerPrintButton.setImage(UIImage(named: "grayTouch"), for: .highlighted)
        }
    }
    
    func refreshLoginState() {
        if self.pinEntry == .Login && UserDefaults.standard.bool(forKey: Constants.kIsFingerPrintEnabled) && !UserDefaults.standard.bool(forKey: Constants.kIsLockedTemporarily) {
            didAuthenticateTouchOnce = false
            authenticateUser()
        }
    }
    
    func setupTemporaryLock() {
        UserDefaults.standard.set(true, forKey: Constants.kIsLockedTemporarily)
        let intervalString = "\(Date().timeIntervalSince1970)"
        UserDefaults.standard.set(intervalString, forKey: Constants.kLockTime)
        UserDefaults.standard.synchronize()
        
        let tempLockScreen = TemporaryLockTimerViewController.create()
        self.navigationController?.pushViewController(tempLockScreen, animated: true)
    }
    
    func resetPinRetries() {
        passwordDoesntMatch?.isHidden = true
        pinRetries = 1
    }
    
    func updateRetryPINLayout() {
        if pinRetries == 2 {
            headingLabel.text = "Oops!"
            subHeadingLabel.text = "Incorrect PIN(2 attempts)"
        } else if pinRetries == 3 {
            headingLabel.text = "Oops!"
            subHeadingLabel.text = "Incorrect PIN(Last attempt)"
        } else {
            headingLabel.text = "Hello!"
            subHeadingLabel.text = enterPinOrTouchIDtext
        }
    }
    
}

extension PinViewController: UITextFieldDelegate {
    
    func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
        let updatedText = textField.text!.replacingCharacters(in: Range(range, in: textField.text ?? "")!, with: string)
        
        selectDotWith(count: updatedText.count)
        
        passwordDoesntMatch.isHidden = true
        passwordDoesntMatch.text = pinDoesntMatchText
        
        if updatedText.count <= 5 {
            
            if updatedText.count == 5 {
                if pinEntry == .Create {
                    router?.routeToReEnterPinScreenWith(pin: updatedText)
                } else if pinEntry == .ReEnter {
                    if createdPin != updatedText {
                        passwordDoesntMatch.isHidden = false
                    } else {
                        textField.text = updatedText
                        codeTextField.resignFirstResponder()

                        pinCreationAndMatchingDoneLocally()
                    }
                } else {
                    textField.text = updatedText
                    codeTextField.resignFirstResponder()
                    
                    doLoginCheckWith(pin: updatedText)
                }
            }
            
            return true
        } else {
            if pinEntry == .ReEnter {
                passwordDoesntMatch.isHidden = false
            }
        }
        
        return false
    }
    
}
