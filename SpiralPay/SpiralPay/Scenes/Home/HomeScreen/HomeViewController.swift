//
//  HomeViewController.swift
//  SpiralPay
//
//  Created by Zoeb on 22/02/18.
//  Copyright (c) 2018 EnvisionWorld. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol HomeDisplayLogic: class
{
    func getPaymentHistorySuccessWith(response: [Home.PaymentHistory.Response])
    func getPaymentHistoryFailureWith(response: Home.PaymentHistory.Response)
}

enum DurationType {
    case Week
    case Month
}

class HomeViewController: SpiralPayViewController, HomeDisplayLogic
{
    var interactor: HomeBusinessLogic?
    var router: (NSObjectProtocol & HomeRoutingLogic & HomeDataPassing)?
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = HomeInteractor()
        let presenter = HomePresenter()
        let router = HomeRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?)
    {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        
        paymentTableView.estimatedRowHeight = 0
        paymentTableView.estimatedSectionHeaderHeight = 0
        paymentTableView.estimatedSectionFooterHeight = 0
        
        getPaymentHistory()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        self.paymentTableView.reloadData()
    }
    
    //MARK:- Variables
    @IBOutlet weak var graphView: UIView!
    @IBOutlet weak var monthButton: UIButton!
    @IBOutlet weak var weekButton: UIButton!
    @IBOutlet weak var customSegmentBlueView: UIView!
    @IBOutlet weak var customSegmentBlueViewTrailingConstraint: NSLayoutConstraint!
    @IBOutlet weak var paymentTableViewHeightConstraint: NSLayoutConstraint!
    @IBOutlet weak var paymentTableView: UITableView!
    @IBOutlet weak var noDataLabel: UILabel!
        
    var shapeL: CAShapeLayer?
    var dotsL: CAShapeLayer?
    
    var payments = [[Home.PaymentHistory.Response]]()
    var maxAmount = 0
    var durationType: DurationType = .Week
    
    let imageCache = NSCache<NSString, AnyObject>()
    
    let baseURL = "\(AppSettingsManager.sharedInstance.appSettings.EnableSecureConnection ? Constants.SecureProtocol : Constants.InsecureProtocol)\(AppSettingsManager.sharedInstance.appSettings.ProductionURL)"
    
    //MARK:- APIs
    
    func getPaymentHistory() {
        noDataLabel.isHidden = true
        NLoader.shared.startNLoader()
        var request = Home.PaymentHistory.Request()
        
        var dayComp = DateComponents()
        if durationType == .Week {
            dayComp.day = -7
        } else {
            dayComp.month = -1
        }
        let date = Calendar.current.date(byAdding: dayComp, to: Date())!
        
        request.from = "\( Int(date.timeIntervalSince1970 * 1000) )"
        interactor?.getPaymentHistory(request: request)
    }
    
    func getPaymentHistorySuccessWith(response: [Home.PaymentHistory.Response]) {
        NLoader.shared.stopNLoader()
        
        if response.count == 0 {
            noDataLabel.isHidden = false
        }
        read(response: response)
        
        reloadPaymentTableViewData()
    }
    
    func getPaymentHistoryFailureWith(response: Home.PaymentHistory.Response) {
        NLoader.shared.stopNLoader()
        payments = []
        clearGraph()
        reloadPaymentTableViewData()
    }
    
    func read(response: [Home.PaymentHistory.Response]) {
        
        var previousDateString = ".."
        payments = []
        
        var count = 0
        var dayWiseMaxAmount = 0
        maxAmount = 0
        for payment in response {
            let paymentDateString = self.getFormatterStringWith(timeInterval: payment.created)
            
            if paymentDateString == previousDateString {
                payments[payments.count - 1].append(response[count])
                dayWiseMaxAmount = dayWiseMaxAmount + (response[count].amount ?? 0)
            } else {
                payments.append([response[count]])
                previousDateString = paymentDateString
                
                dayWiseMaxAmount = response[count].amount ?? 0
            }
            
            if maxAmount < dayWiseMaxAmount {
                maxAmount = dayWiseMaxAmount
            }
                
            count = count + 1
        }
        
        self.reloadPaymentTableViewData()
        
        drawGraphWith(payments1Darray: response)
    }
    
    func getFormatterStringWith(timeInterval: Int?) -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "E, dd MMM"
        
        let paymentDate = Date(timeIntervalSince1970: Double(timeInterval ?? 0)/1000)
        let paymentDateString = dateFormatter.string(from: paymentDate)
        
        return paymentDateString
    }
    
    //MARK:- Private methods
    
    private func reloadPaymentTableViewData() {
        paymentTableView.reloadData()
        self.paymentTableViewHeightConstraint.constant = self.paymentTableView.contentSize.height
        self.view.layoutIfNeeded()
    }
    
    private func drawGraphWith(payments1Darray: [Home.PaymentHistory.Response]) {
        clearGraph()
        var points = Array<CGPoint>()
        let currentDate = Date()
        var dayComp = DateComponents()
        
        for payment in payments1Darray {
            let xValue = getPointFor(dateInterval: payment.created ?? 0,
                                     currentDate: currentDate,
                                     dateComponent: &dayComp)
            let yValue = getPointFor(amount: payment.amount ?? 0)
            
            points.append(CGPoint(x: xValue, y: yValue))
        }
        
        addLineGraphWith(points: points)
        addDotsTo(points: points)
    }
    
    private func getPointFor(dateInterval: Int, currentDate: Date, dateComponent: inout DateComponents) -> CGFloat {
        
        var startingDate: Date?
        if durationType == .Week {
            dateComponent.day = -7
            dateComponent.month = 0
            startingDate = Calendar.current.date(byAdding: dateComponent, to: currentDate)!
        } else {
            dateComponent.day = 0
            dateComponent.month = -1
            startingDate = Calendar.current.date(byAdding: dateComponent, to: currentDate)!
        }
        let startingDateInterval = CGFloat(startingDate!.timeIntervalSince1970)
        let currentDateInterval = CGFloat(currentDate.timeIntervalSince1970)
        
        let percentage = ((CGFloat(dateInterval)/1000 - startingDateInterval) / (currentDateInterval - startingDateInterval))
        
        return percentage * graphView.frame.size.width
    }
    
    private func getPointFor(amount: Int) -> CGFloat {
        let percentage = CGFloat(amount) / CGFloat(maxAmount)
        return percentage * graphView.frame.size.height
    }
    
    private func clearGraph() {
        if let sublayers = graphView.layer.sublayers {
            for layer in sublayers {
                layer.removeFromSuperlayer()
            }
        }
    }
    
    private func addLineGraphWith(points: [CGPoint]) {
        let aPath = UIBezierPath.interpolateCGPointsWithHermite(pointsAsNSValues: points as Array<AnyObject>, closed: false)
        
        if aPath != nil {
            shapeL = CAShapeLayer()
            shapeL!.path = aPath!.cgPath
            shapeL!.fillColor = UIColor.clear.cgColor
            shapeL!.strokeColor = Colors.pink.cgColor
            shapeL!.lineWidth = 1
            
            shapeL!.masksToBounds = false
            shapeL!.shadowColor = UIColor.black.cgColor
            shapeL!.shadowOpacity = 0.2
            shapeL!.shadowOffset = CGSize(width: 0, height: 2)
            shapeL!.shadowRadius = 2
            shapeL!.shouldRasterize = true
            
            graphView.layer.addSublayer(shapeL!)
        }
    }
    
    private func addDotsTo(points: [CGPoint]) {
        dotsL = CAShapeLayer()
        for point in points {
            let greyDot = CAShapeLayer()
            
            let greyDotPath = UIBezierPath(arcCenter: point,
                                           radius: 8,
                                           startAngle: 0,
                                           endAngle: 6*CGFloat.pi,
                                           clockwise: true)
            greyDot.path = greyDotPath.cgPath
            greyDot.fillColor = UIColor(red: 240/255, green: 240/255, blue: 240/255, alpha: 0.9).cgColor
            
            greyDot.masksToBounds = false
            greyDot.shadowColor = UIColor.black.cgColor
            greyDot.shadowOpacity = 0.2
            greyDot.shadowOffset = CGSize(width: 0, height: 2)
            greyDot.shadowRadius = 2
            greyDot.shouldRasterize = true
            
            dotsL?.addSublayer(greyDot)
            
            let dot = CAShapeLayer()
            
            let pinkDotPath = UIBezierPath(arcCenter: point,
                                           radius: 4,
                                           startAngle: 0,
                                           endAngle: 6*CGFloat.pi,
                                           clockwise: true)
            dot.path = pinkDotPath.cgPath
            dot.fillColor = Colors.pink.cgColor
            dotsL?.addSublayer(dot)
        }
        
        graphView.layer.addSublayer(dotsL!)
    }
    
    func downloadImageFrom(url: URL, for imageView: UIImageView) {
        
        if let cachedImage = imageCache.object(forKey: url.absoluteString as NSString) as? UIImage {
            imageView.image = cachedImage
        } else {
            URLSession.shared.dataTask(with: url) { data, response, error in
                guard let data = data, error == nil else { return }
                DispatchQueue.main.async {
                    let imageToCache = UIImage(data: data)
                    self.imageCache.setObject(imageToCache!, forKey: url.absoluteString as NSString)
                    imageView.image = imageToCache
                }
                }.resume()
        }
    }
    
    //MARK:- IBAction methods
    
    @IBAction func thisWeekButtonTapped() {
        customSegmentBlueViewTrailingConstraint.constant = 0
        UIView.animate(withDuration: 0.3) {
            self.view.layoutIfNeeded()
        }
        
        UIView.transition(with: weekButton,
                          duration: 0.3,
                          options: .transitionCrossDissolve,
                          animations: {
                            self.weekButton.setTitleColor(.white, for: .normal)
        },
                          completion: nil)
        
        UIView.transition(with: monthButton,
                          duration: 0.3,
                          options: .transitionCrossDissolve,
                          animations: {
                            self.monthButton.setTitleColor(UIColor(white: 130/255, alpha: 1), for: .normal)
        },
                          completion: nil)
        
        durationType = .Week
        getPaymentHistory()
    }
    
    @IBAction func thisMonthButtonTapped() {
        customSegmentBlueViewTrailingConstraint.constant = customSegmentBlueView.frame.size.width
        UIView.animate(withDuration: 0.3) {
            self.view.layoutIfNeeded()
        }
        
        UIView.transition(with: weekButton,
                          duration: 0.3,
                          options: .transitionCrossDissolve,
                          animations: {
                            self.weekButton.setTitleColor(UIColor(white: 130/255, alpha: 1), for: .normal)
        },
                          completion: nil)
        
        UIView.transition(with: monthButton,
                          duration: 0.3,
                          options: .transitionCrossDissolve,
                          animations: {
                            self.monthButton.setTitleColor(.white, for: .normal)
        },
                          completion: nil)
        
        durationType = .Month
        getPaymentHistory()
    }
    
    private func getURLfor(payment: Home.PaymentHistory.Response) -> URL {
        let url = "\(baseURL)/v1/file/\(payment.merchantLogoId ?? "")/public"
        return URL(string: url)!
    }
}

extension HomeViewController: UITableViewDelegate, UITableViewDataSource {
    
    //Sections are added cells in rows only to avoid complications
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return payments.count
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return payments[section].count + 1 //1 is for section cell
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        if indexPath.row == 0 {
            let cell = tableView.dequeueReusableCell(withIdentifier: "PaymentHeaderCell", for: indexPath)
            
            if let label = cell.viewWithTag(101) as? UILabel {
                let created = payments[indexPath.section][indexPath.row].created
                label.text = self.getFormatterStringWith(timeInterval: created)
            }
            
            return cell
        } else {
            let cell = tableView.dequeueReusableCell(withIdentifier: "PaymentCell", for: indexPath)
            guard let merchantImageView = cell.viewWithTag(101) as? UIImageView else {
                return cell
            }
            guard let merchantNameLabel = cell.viewWithTag(102) as? UILabel else {
                return cell
            }
            guard let amountLabel = cell.viewWithTag(103) as? UILabel else {
                return cell
            }
            let payment = payments[indexPath.section][indexPath.row - 1] // 1 substract as section is 1st always
            
            merchantNameLabel.text = payment.merchantName
            downloadImageFrom(url: getURLfor(payment: payment), for: merchantImageView)
            if payment.currency == "GBP" {
                amountLabel.text = "£\(payment.amount ?? 0)"
            } else {
                amountLabel.text = "\(payment.amount ?? 0) \(payment.currency ?? "")"
            }
            
            return cell
        }
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        if indexPath.row == 0 {
            return 60
        } else {
            return 55
        }
    }
    
}
